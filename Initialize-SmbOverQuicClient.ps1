#requires -RunAsAdministrator
#requires -Version 7.4

using namespace System.Collections.Generic
#using module .\class\libFunction.psm1

<#
    Aids in setting up an SMB over QUIC server on Windows Server 2025 Preview.

    This script is built and tested using PowerShell 7.4.2. It's possible this will work with Windows PowerShell 5.1 
    by removing "#requires -Version 7.4" in line 2, but it is untested. the clean{} section must be moved/migrated to
    end{} if you attempt to run this in legacy Windows PowerShell.

    Windows Server 2025 has Windows Terminal and winget installed by default. PowerShell 7.4 is the current LTS version 
    of PowerShell. Windows PowerShell 5.1 has not seen significant updates in several years. It's time to move on...
    
    To install PowerShell on Windows Server 2025:

    - Open an elevated (Run as administrator) Terminal or Windows PowerShell console.
    - Run this command:

        winget install Microsoft.PowerShell

    -OR-

    ... download and install PowerShell from:

    https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell?view=powershell-7.4

    - Open Terminal settings (Ctrl+,).
    - Change the default profile from Windows PowerShell to PowerShell.



    LEGAL STUFF

    This sample code is provided AS-IS with no warranties or guarantees. Use at your own risk. These scripts are not 
    officially Microsoft supported code or processes.

#>

[CmdletBinding()]
param (
    ## PKI MODE ##
    # This parameters causes the script to search for a local valid script and use the ServerName parameter to configure the SMB over QUIC client.
    [Parameter(ParameterSetName = 'pki')]
    [switch]
    $PKI,

    ## EXISTING CERT PARAMETERS ##

    # A valid certificate object. See https://learn.microsoft.com/en-us/windows-server/storage/file-server/smb-over-quic#deploy-smb-over-quic for certificate requirements.
    [Parameter(Mandatory=$true, ParameterSetName = 'CertObj', ValueFromPipeline=$true)]
    [System.Security.Cryptography.X509Certificates.X509Certificate2]
    $Certificate,

    # The certificate thumbprint of a valid certificate. See https://learn.microsoft.com/en-us/windows-server/storage/file-server/smb-over-quic#deploy-smb-over-quic for certificate requirements.
    [Parameter(Mandatory, ParameterSetName = 'CertThumb')]
    [string]
    $Thumbprint,


    ## SELF-SIGNED CERT PARAMETERS ##

    # Generates a self-signed certificate. Please only use this option for testing.
    [Parameter(Mandatory, ParameterSetName = 'SSC')]
    [switch]
    $SelfSignedCert,

    # The subject name of the certificate. Can be any string following cert subject naming standards (alphanumerical characters only). Cannot be blank.
    [Parameter(Mandatory, ParameterSetName = 'SSC', Position = 0)]
    [string]
    $Subject,

    # A friendly name for the certificate.
    [Parameter(Mandatory=$false, ParameterSetName = 'SSC', Position = 1)]
    [string]
    $FriendlyName,
    
    <# The comma separated list of Subject Alternative Names (SAN) for the certificate. This should be a full list of the SMB server names the client will be accessing. Including:
    
    - FQDN
    - Short name (NETBIOS)
    - Cluster name

    #>
    [Parameter(Mandatory, ParameterSetName = 'SSC', Position = 2)]
    [Alias("SAN", "SubjectAlternateNames","ServerDnsNames")]
    $DnsNames,
    
    # The certificate signature hash algorithm. Valid options are: SHA256, SHA384, SHA512
    [Parameter(Mandatory = $false, ParameterSetName = 'SSC', Position = 3)]
    [ValidateSet("SHA256", "SHA384", "SHA512")]
    $SignatureHash = "SHA256",

    # The certificate public key algorithm. Valid options are: ECDSA_P256 (256), ECDSA_P384 (384), ECDSA_P521 (521), RSA (2048), RSA (4096)
    [Parameter(Mandatory = $false, ParameterSetName = 'SSC', Position = 4)]
    [ValidateSet("ECDSA_P256", "ECDSA_P384", "ECDSA_P521", "RSA_2048", "RSA_4096")]
    $PublicKeyAlgorithm = "ECDSA_P256",

    # Certificate expiration date.
    [Parameter(Mandatory = $false, ParameterSetName = 'SSC', Position = 5)]
    [ValidateScript({$_ -gt ([DateTime]::Now)})]
    $NotAfter = ((Get-Date).AddMonths(12)),

    # The export the self-signed certificate CER file (X.509 certificate file). The filename is autogenerated as: <subject>_<timestamp>.cer
    [Parameter(Mandatory = $false, ParameterSetName = 'SSC', Position = 6)]
    [string]
    $ExportPath = "$($PWD.Path)",

    ### ALL PROFILES ### - Except NoLocal

    # Full path to the SMB over QUIC server certificate. The certificate must be an X.509 CER file.
    [string]
    $ServerCertificatePath = $null,

    # The server certificate thumbprint. Used to generate commands when the server certificate is already installed.
    [string]
    $ServerCertificateThumbprint = $null,

    # The SMB over QUIC server's DNS name(s). Use this for Enterprise Root PKI configurations where the server certificate will not be locally installed because of inherent PKI trust.
    [string[]]
    $ServerName,

    # Locaiton to write log files. Log files are not written without this explicit parameter.
    [string]
    $LogPath = $null,

    # Returns a PSCustomObject which contains the certificate validation results and two sets of SMB over QUIC server Grant-SmbClientAccessToServer commands for ISSUER and SHA256 identity types. This option squelches console output.
    [switch]
    $PassThru
)


begin {
    # bail is not run on Windows
    if (-NOT $IsWindows) {
        throw "Unsupported operating system."
    }

    # import required classes
    try {
        . "$PSScriptRoot\class\libLogging.ps1"
    } catch {
        return ( Write-Error "Failed to import a required class library: $_" -EA Stop )
    }#>

    # the minimum key length supported by TLS 1.3 is 256-bits
    $MIN_KEY_LEN = 256

    # a list of TLS 1.3 PKAs that can be passed to new-selfsignedcertificate
    $VALID_PKA_NAMES = "ECDSA_P256", "ECDSA_P384", "ECDSA_P521", "RSA"

    # a list of certificate file extensions supported by Import-Certificate
    $VALID_CERT_FILE_EXTENSIONS = ".sst", ".p7b", ".cert", ".cer"

    # get the OS build number
    $osBuild = [System.Environment]::OSVersion | ForEach-Object {$_.Version.Build}

    # the minimum OS build number for SMB client access control (CAC) (Windows 11 24H2 and Windows Server 2025)
    $minCACBuild = 26100

    <#
        Write-Log ""
        Write-LogError -Code "" -Text "" [-NonTerminating]
        Write-LogWarning -Code "" -Text ""
    #>

    # start logging
    $oldLogMod = Start-Logging -ModuleName ((Get-PSCallStack)[0].Command.Split('.')[0]) -LogPath $LogPath

    Write-Log "Enter begin"
    
    $initPassThru = $PassThru.IsPresent
    Write-Log "Initial PassThru value: $($PassThru.IsPresent)"

    # for now, make sure we are in the script root path
    Push-Location "$PSScriptRoot"

    # certificate store path for SMB over QUIC certificates
    Write-Log "Get certificate store."
    #$certStorePath = "Cert:\LocalMachine\My"
    $certStorePath = "Microsoft.PowerShell.Security\Certificate::LocalMachine\My"
    $certStore = Get-Item $certStorePath

    $certStoreRootPath = "Cert:\LocalMachine\Root"

    Write-Log "Exit begin"
}

process {
    Write-Log "Enter process"

    Write-Log "PSBoundParameters:`n$($PSBoundParameters | Format-List | Out-String)"
    <#
        Order of operation:
            - Self-signed
            - Certificate object
            - Thumbprint
    #>

    if ($SelfSignedCert.IsPresent) {
        Write-Log "Generating a self-signed certificate for the server."

        # RSA_<key length> needs to be converted down to something supported by the cmdlet
        $script:PublicKeyAlgo = ""
        
        # need to figure out the key length
        [int32]$KeyLength = -1
        switch -Regex ($PublicKeyAlgorithm) {
            "^ECDSA_P.*$" {
                $KeyLength = $PublicKeyAlgorithm | Select-String -Pattern "^ECDSA_P(?<len>\d{3})$" | ForEach-Object { $_.matches.Groups[1].Value }
                $script:PublicKeyAlgo = $PublicKeyAlgorithm
            }

            "^RSA.*$" {
                $KeyLength = $PublicKeyAlgorithm.split('_')[1]
                $script:PublicKeyAlgo = "RSA"
            }

            # just in case...
            default {
                Write-LogError -Code "INVALID_PKA" -Text "The Public Key Algorithm, $PublicKeyAlgorithm, is not supported."
            }
        }

        Write-Log "KeyLength: $KeyLength"
        Write-Log "PublicKeyAlgo: $script:PublicKeyAlgo"

        # do some checks
        if ($KeyLength -lt $MIN_KEY_LEN) {
            Write-LogError -Code "INVALID_KEY_LENGTH" -Text "The Key Length, $KeyLength, is not supported by TLS 1.3."
        }

        # the $script:PublicKeyAlgo variable must be valid
        if ($script:PublicKeyAlgo -notin $VALID_PKA_NAMES) {
            Write-LogError -Code "PKA_NOT_FOUND" -Text "The Public Key Algorithm, $script:PublicKeyAlgo, is not on the validation list."
        }

        # validate the export path
        if ( -NOT (Test-Path "$ExportPath" -IsValid -EA SilentlyContinue)) {
            Write-LogWarning -Code "INVALID_EXPORT_PATH" -Text "The export path () is invalid. Using PWD ($($PWD.Path))."
            $ExportPath = "$($PWD.Path)"
        }

        # the path is valid, create it if missing
        $epFnd = Get-Item "$ExportPath" -EA SilentlyContinue
        if (-NOT $epFnd) {
            try {
                $null = New-Item -Path "$ExportPath" -ItemType Directory -Force -EA Stop
                Write-Log "Export path created at: $ExportPath"
            } catch {
                # throw a warning and use PWD if creating the path failed.
                Write-LogWarning -Code "CREATE_EXPORT_PATH_FAILED" -Text "Failed to create the export path. Using PWD ($($PWD.Path)). Error: $_"
                $ExportPath = "$($PWD.Path)"
            }
        }

        Write-Log "Exporting the certificate to: $ExportPath"

        # Don't change anything below here...
        # create a hashtable of the cmdlet parameters
        $certSplat = @{
            Subject          = $Subject
            FriendlyName     = $FriendlyName
            KeyUsageProperty = "Sign"
            KeyUsage         = "DigitalSignature"
            CertStoreLocation = $certStore.PSPath
            HashAlgorithm     = $SignatureHash
            Provider          = "Microsoft Software Key Storage Provider"
            KeyAlgorithm      = $script:PublicKeyAlgo
            KeyLength         = $KeyLength
            NotAfter          = $NotAfter
            DnsName           = $DnsNames
        }

        Write-Log "Cert properties:`n$($certSplat | Format-List | Out-String)`n"

        # execute the command using splatting
        try {
            Write-Log "Creating the self signed certificate."
            $Certificate = New-SelfSignedCertificate @certSplat -EA Stop
            Write-Log "Creation successful."
        } catch {
            Write-LogError -Code "CERT_CREATION_ERROR" -Text "Failed to create the self-signed certificate: $_"
            #return ( Write-Error "Failed to create the self-signed certificate: $_" -EA Stop )
        }

        # export a CER file
        $selfSignFileName = "$Subject`_$(Get-Date -Format "yyyyMMddHHmmss")`.cer"
        # clean up any invalid path chars
        $selfSignFileName = $selfSignFileName -replace "[$([RegEx]::Escape([string][IO.Path]::GetInvalidFileNameChars()))]+","_"

        # generate the full path
        $selfSignFile = "$ExportPath\$selfSignFileName"

        # perform the export
        try {
            $null = Export-Certificate -Cert $Certificate -Type CERT -FilePath "$selfSignFile" -EA Stop 
            Write-Log "Exported the self signed certificate to $selfSignFile"

            Write-Host -ForegroundColor Green "The SMB over QUIC server certificate has been exported to: $selfSignFile"

            # import the cert to the Root store
            $null = Import-Certificate -FilePath "$selfSignFile" -CertStoreLocation $certStoreRootPath -EA Stop
            Write-Log "Imported the self signed certificate to the Root store."
        } catch {
            Write-LogError -Code "SELF_CERT_IMPORT_FAILURE" -Text "Failed to import the self signed certificate to the Root store and create a trusted certificate chain: $_"
        }
    } elseif ( $null -ne $Certificate ) {
        <#
            Validation handles most of the checks.
            Certificate can only be a X509Certificate2 object so no need to validate this.
            Just need to make sure the certificate is in the right place in this block.
        #>
        # is the certificate in the proper store?
        Write-Log "Checking certificate path."
        if ($Certificate.PSParentPath -ne $certStorePath) {
            Write-LogError -Code "INVALID_CERT_STORE" -Text "The certificate is not in the correct store. Current store: $($Certificate.PSParentPath); Required store: $certStorePath"
        }
    } elseif ( -NOT [string]::IsNullOrEmpty($Thumbprint) ) {
        # Convert the thumbprint to a cert object
        try {  
           Write-Log "Searching for a certificate with thumbprint $Thumbprint."
           $Certificate = Get-ChildItem $certStorePath -EA Stop | Where-Object Thumbprint -eq $Thumbprint
           Write-Log "Certificate: $Certificate"
        } catch {
            Write-LogError -Code "CERT_STORE_FAILURE" -Text "Failed to open the certificate store: $_"
        }

        if ( -NOT $Certificate -or $Certificate.Thumbprint -ne $Thumbprint) {
            Write-LogError -Code "THUMB_NOT_FOUND" -Text "Failed to retrive a certficate with the thumbprint $Thumbprint in $certStorePath"
        }

    } else {
        ## attempt to auto-detect the client certificate
        # get a list of certificates in LocalMachine\My that meet a minimum baseline
        [array]$allCliCerts = Get-ChildItem Cert:\LocalMachine\My | Where-Object {$_.EnhancedKeyUsageList.ObjectId -Contains '1.3.6.1.5.5.7.3.2' -and $_.DnsNameList.Unicode.Count -ge 1}

        if ($allCliCerts.Count -ge 1) {
            ## at least one option was found
            # stores a list of valid certs
            $valCerts = [List[Object]]::new()


            # filter out the ones where none of the SANs contain the COMPUTERNAME or fail validation
            $templateNames = 'SMB over QUIC','SoQ','SMB'
            foreach ($cer in $allCliCerts) {
                $vCert = . .\Validate-SmbOverQuicCertificate.ps1 -Thumbprint $cer.Thumbprint -EKUType "Client" -PassThru 

                # add to the list only if validation passed
                if ($vCert.IsCertValid) {
                    $valCerts.Add($cer)
                }
            }

            # now figure out if anything valid was found
            if ($valCerts.Count -eq 1) {
                # easy mode, only one cert found, use that
                $Certificate = $valCerts[0].Certificate
                Write-Log "Found one valid certificate. Thumbprint: $($Certificate.Thumbprint)"
            } elseif ($valCerts.Count -gt 1) {
                Write-Log "Trying to discover the best possible certificate. Number of certificates to check: $($valCerts.Count)"
                # hard mode - more than one possible certificate found
                # pick the certificate that matches published certificate template guidelines: "SMB over QUIC" or "SoQ" or "SMB"
                # simply pick the first match...
                :certLoop foreach ($cer in $valCerts) {
                    Write-Log "Checking template of: $($cer.Thumbprint)"
                    $template = $cer.extensions.format(1) | Select-String -Pattern "Template=(?<tName>.*)\(" | ForEach-Object {$_.Matches.Groups[1].Value}
                    Write-Log "Discovered template: $template"
                
                    if ([string]::IsNullOrEmpty($template)) {
                        Write-Log "Empty template, moving on."
                        continue certLoop
                    }

                    foreach ($tn in $templateNames) {
                        Write-Log "$tn -match $template = $($template -match $tn)"
                        if ($template -match $tn) {
                            Write-Log "Template match! Using certificte $($cer.Thumbprint)."
                            $Certificate = $cer
                            break certLoop
                        }
                    }

                    Write-Log "No template matches."
                }

                if (-NOT $Certificate ) {
                    Write-Log "Unable to detect based on template. Using:`n$($valCerts[0])"
                    # no matching template, pick the first cert in the list
                    $Certificate = $valCerts[0]
                }

            } else {
                Write-LogError -Code "NO_CLIENT_CERT_FOUND" -Text "No valid client certificate was found."
            }
        } else {
            Write-LogError -Code "INVALID_CERT" -Text "Invalid or missing client certificate."
        }
        
    }

    <# Validate the certificate using Validate-SmbOverQuicCertificate.ps1
    if ($valCert -is [System.Security.Cryptography.X509Certificates.X509Certificate] -and -NOT $Certificate) {
        $Certificate = $validCert 
        Write-Log "Updating Certificate. Certificate:`n$Certificate"
    }#>

    # Validate the client certificate.
    if ($Certificate) {
        Write-Log "Validating the certificate."
        $validCert = . .\Validate-SmbOverQuicCertificate.ps1 -Thumbprint $Certificate.Thumbprint -EKUType "Client" -PassThru
        Write-Log "IsCertValid: $($validCert.IsCertValid)"

        # bail if the certificate validation failed
        if ( -NOT $validCert.IsCertValid ) {
            $errTxt = "The certificate is not valid for SMB over QUIC: $($validCert.IsCertValid)`n`nPlease run this command for more details: Validate-SmbOverQuicCertificate -Thumbprint $($Certificate.Thumbprint) -Detailed"
            Write-LogError -Code "CERT_VALIDATION_FAILURE" -Text $errTxt
        }
    # Fail if there is no certificate at this point
    } else {
        Write-LogError -Code "UNKNOWN_VALIDATION_ERROR" -Text "Something went terribly, horribly wrong. No certificate was found. validCert: $($validCert.GetType().Name)`n$validCert`nCertificate: $Certificate"
    }

    

    # get the SHA256 hash of the Certificate
    $certHash = $validCert.Certificate.GetCertHashString([System.Security.Cryptography.HashAlgorithmName]::Sha256)

    # import the server certificate when a path value is passed
    # retrieve the server certificate when a thumbprint is passed
    $srvCert = ""
    if ( -NOT [string]::IsNullOrEmpty($ServerCertificatePath) ) {
        Write-Log "Importing the SMB over QUIC server certificate from: $ServerCertificatePath"
        # make sure the file is there
        $certFnd = Get-Item "$ServerCertificatePath" -EA SilentlyContinue

        # do the import
        if ( $certFnd.Exists ) {
            Write-Log "Server certificate file found."
            # test whether the file extension supported
            if ( $certFnd.Extension -notin $VALID_CERT_FILE_EXTENSIONS ) {
                Write-LogWarning -Code "SERVER_CERT_IMPORT_FAILURE" -Text "Failed to import the SMB over QUIC server certificate. Path: $ServerCertificatePath; Error: $_"
            } else {
                # perform the SoQ server cert import
                $srvCert = Import-Certificate -FilePath "$ServerCertificatePath" -CertStoreLocation $certStoreRootPath -Confirm:$false -EA SilentlyContinue

                if ($srvCert) {
                    Write-Log "Import successful!"
                } else {
                    Write-LogWarning -Code "SERVER_CERT_IMPORT_FAILURE" -Text "Failed to import the SMB over QUIC server certificate. Path: $ServerCertificatePath; Error: $_"
                }
            }
        } else {
            Write-LogWarning -Code "SERVER_CERT_NOT_FOUND" -Text "Failed to find the SMB over QUIC server certificate. The client commands will not be generated."
        }
    } elseif ( -NOT [string]::IsNullOrEmpty($ServerCertificateThumbprint) ) {
        # only look in the LocalMachine\Root store 
        $srvCert = Get-Item Cert:\LocalMachine\Root\$ServerCertificateThumbprint -EA Stop
        
        if ($srvCert) {
            Write-Log "Server certificate found!"
        } else {
            Write-LogWarning -Code "SERVER_CERT_THMB_NOT_FOUND" -Text "A certificate with the thumbprint $ServerCertificateThumbprint was not found in CERT:\LocalMachine\Root. The client commands will not be generated."
        }
    }
    
    Write-Log "Exit process"
}

end {
    Write-Log "Enter end"

    # skip this step when there is no $srvCert
    if ( ($srvCert -and $srvCert -is [System.Security.Cryptography.X509Certificates.X509Certificate]) -or $ServerName.Count -gt 0 ) {
        Write-Log "Creating client import command(s)...`n"

        # pull out the unique names in case that strange duplication thing creeps up
        if ($ServerName.Count -eq 0) {
            # get the server cert subject
            $srvSubject = $srvCert.SubjectName | ForEach-Object Name | ForEach-Object { $_.Split('=')[-1] }
            Write-Log "Server cert subject name: $srvSubject"
            
            $ServerName = $srvCert.DnsNameList.Unicode | Sort-Object -Unique
        } else {
            # prep data based on ServerName
            $ServerName = $ServerName | Sort-Object -Unique
            $srvSubject = $ServerName[0]
        }
        
        Write-Log "Found the following server cert SANs: $($ServerName -join ', ')"

        # used to ouput to console or return an object for PassThru
        $finalResults = [PSCustomObject]@{
            ClientCertificate = $validCert
            CertificateHash   = $certHash
            ServerName        = $ServerName
            ClientMappings    = [PSCustomObject]@{
                                    Count = 0
                                    Command = [List[string]]::new()
                                }
            GrantCommands     = [PSCustomObject]@{
                                    ISSUER = [List[string]]::new()
                                    SHA256 = [List[string]]::new()
                                }
        }

        # generate the certificate issuer DN
        $cliCertIssuer = $validCert.Certificate.Issuer

        # do SMB CAC mappings and commands if CAC is supported on this OS
        if ($osBuild -ge $minCACBuild) {
            # create the SMB client certificate mapping(s) and server commands
            foreach ($name in $ServerName) {
                # skip if the name is not a valid DNS name or the OS build does not support CAC...
                if ( ([System.Uri]::CheckHostName($name)) -ne "Unknown" ) {
                    try {
                        Write-Log "Mapping certificate $($validCert.Certificate.Thumbprint) to server name: $name"
                        # create the local certificate mapping - this is a terminating error!
                        $lclResult = New-SmbClientCertificateMapping -Namespace $name -Thumbprint $validCert.Certificate.Thumbprint -Store My -EA Stop
                        Write-Log "Client mapping result:`n$($lclResult | Format-Table | Out-String)"

                        # update results
                        $finalResults.ClientMappings.Count += 1
                        $finalResults.ClientMappings.Command.Add("New-SmbClientCertificateMapping -Namespace $name -Thumbprint $($validCert.Certificate.Thumbprint) -Store My -EA Stop")
                    } catch {
                        Write-LogWarning -Code "CERT_MAP_ERROR" -Text "Failed to map the certificate ($($validCert.Certificate.Thumbprint)) to $name`: $_"
                    } finally {
                        # generate and record the commands
                        $finalResults.GrantCommands.ISSUER.Add("Grant-SmbClientAccessToServer -Name $name -IdentifierType ISSUER -Identifier '$cliCertIssuer' -Description 'Allow $env:ComputerName via $name server name.' -Force")
                        $finalResults.GrantCommands.SHA256.Add("Grant-SmbClientAccessToServer -Name $name -IdentifierType SHA256 -Identifier $certHash -Description 'Allow $env:ComputerName via $name server name.' -Force")
                    }
                } else {
                    Write-Log "Failed to create a client access mapping command for $name, which is an invalid DNS name."
                }
            } else {
                Write-LogWarning -Code "SMB_CAC_NOT_SUPPORTED" -Text "SMB over QUIC client access control is not supported on this build of Windows. Minimum build: $minCACBuild; Current Build: $osBuild"
            }
        }

        Write-Log "initPassThru: $initPassThru"
        # output decisions go here
        if ($initPassThru) {
            Write-Log "PassThru final results."
            Write-Log @"
Results
   - Client Certificate Validation
$($finalResults.ClientCertificate.ToString())
    
    - Client Certificate Hash
$($finalResults.CertificateHash)

    - SMB over QUIC Server Name(s)
$($finalResults.ServerName -join "`n`n")

    - Number of SMB over QUIC client mapping created: $($finalResults.ClientMappings.Count)

    - Client Mapping Commands
$($finalResults.ClientMappings.Command -join "`n`n")

    - SMB over QUIC Grant Client Access Commands
        - ISSUER:
$($finalResults.GrantCommands.ISSUER -join "`n`n")

        - SHA256
$($finalResults.GrantCommands.SHA256 -join "`n`n")
"@
            return $finalResults
        } elseif ($SelfSignedCert.IsPresent) {
            Write-Log "SelfSignedcert final results."
            Write-Host -ForegroundColor Green "The certificate hash is $certHash.`n"
            Write-Host -ForegroundColor Yellow "Please remember to import the client certificate on the SMB over QUIC server!`n"
            $text = @"
1. Copy $selfSignFile to the SMB over QUIC server.
2. Open an elevated PowerShell (Run as administrator) terminal.
3. Import the certificate to LocalMachine\Root (Local Computer > Trusted Root Certification Authorities > Certificates)

Import-Certificate -FilePath "<path to>\$selfSignFileName" -CertStoreLocation Cert:\LocalMachine\root

4. Run the Grant-SmbClientAccessToServer command (if available).
    To grant access by issuer, such as an Active Directory Enterprise Root CA, use these commands:

$($finalResults.GrantCommands.ISSUER -join "`n")

    To grant per client access, such as a workgroup or high security environment, use these commands:

$($finalResults.GrantCommands.SHA256 -join "`n")
"@
            Write-Host $text
            Write-Log $text
        } else {
            Write-Log "Default final results."
            Write-Host @"
Results
   - Client Certificate Validation
$($finalResults.ClientCertificate.ToString())
    
    - Client Certificate Hash
$($finalResults.CertificateHash)

    - SMB over QUIC Server Name(s)
$($finalResults.ServerName -join "`n`n")

    - Number of SMB over QUIC client mapping created: $($finalResults.ClientMappings.Count)

    - Client Mapping Commands
$($finalResults.ClientMappings.Command -join "`n`n")

    - SMB over QUIC Grant Client Access Commands
        - ISSUER:
$($finalResults.GrantCommands.ISSUER -join "`n`n")

        - SHA256
$($finalResults.GrantCommands.SHA256 -join "`n`n")
"@
        }
    } else {
        Write-Log "No server certificate or server name(s) were provided. Skipping console output."
    }
    Write-Log "Work Complete!"
    Write-Log "Exit end"
}

clean {
    Write-Log "Clean up, clean up, everybody do your part!"

    Close-Logging -ModuleName ((Get-PSCallStack)[0].Command.Split('.')[0]) -oldLogMod $oldLogMod
    
    ################################################
    ###                                          ###
    ###  NO LOGGING ALLOWED PAST CLOSE-LOGGING   ###
    ###                                          ###
    ################################################

    # Use Write-Verbose or Write-Debug if any back channel logging is needed, though it won't be in the log file

}